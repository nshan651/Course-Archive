#include <main.hh>

using namespace std;

bool is_word(const string& word, const unordered_set<string>& dictionary)
{
    return dictionary.count(word) > 0;
}

bool is_letter(char c)
{
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
}

vector<string> split_line(string line)
/** Split line into strings, space-separated */
{
    istringstream iss(line);
    vector<string> parts;
    string part;
    while (iss >> part)
        parts.push_back(part);
    return parts;
}

//vector<vector<string>> parse_dict(vector<vector<string>>& lines, string input_file)
void parse_dict(vector<vector<string>>& lines, string input_file)
/** Parse each line of a file, splitting each line into words. Return an iterator. */
{
    ifstream inputFile(input_file);
    string line;
    while (getline(inputFile, line))
        lines.push_back(split_line(line));
    //return lines;
}

int encoder(Cipher cipher, vector<vector<string>>& lines)
/**
The encoder does the following:
    - Loads the dictionary into a data structure (map/set). As words are loaded in, any words containing characters not in the alphabet will be discarded.
    - Words are all converted to upper case.
    - Generates ”sentences”. You may generate sentences with whitespace or punctuation. Just keep in mind that the decoder must be able to exclude any text not in the input alphabet.
    - Each line of text must be encrypted using the Caesar cipher with a randomly chosen shift key. No information about the key is written to the output.
    -The output lines may either be directed to standard output or to a file.
*/
{

    return 0;
}

int decoder(Cipher cipher, vector<vector<string>>& lines)
/** 
The decoder does the following:
    - Reads one line of input at a time.
    - Parses the line of input into words. A word is any continuous sequence of letters from the alphabet.
    - Characters not in a word should be preserved to the fullest extent possible (e.g. whitespace and any punctuation.)
    - Try all shift values with your Caesar cipher to see if all words in a line of input can be decoded. You will know if they can be decoded by looking up the words in the dictionary. Thus the decoder must be able to load the dictionary as well.
    - Output the shift value on success. If for any reason an input line cannot be decoded, output a -1. This would never happen if your encoder and decoder are both working, but it is entirely possible a file generated by someone else could present problems.
    - You can also write the decoder to succeed if most of the words are decoded. This could be an additional command line option, e.g. --threshold=percentage.
*/
{
    for_each(lines.begin(), lines.end(), [](vector<string> line) {
        for_each(line.begin(), line.end(), [](string word) {
           cout << word << "\n"; 
        });
     });

    return 0;
}

int main(int argc, char **argv)
{
    int option;
    Cipher cipher;
    while ((option = getopt(argc, argv, "edn:l:x:i:o:h")) != -1) {
        switch (option) {
            case 'e':
                cout << "Encrypt selected.";
                cipher.encrypt = true; 
                break;
            case 'd':
                cout << "Decrypt selected";
                cipher.encrypt = false; 
                break;
            case 'n':
                cipher.num_lines = atoi(optarg);
                cout << "Line number option selected.";
                break;
            case 'l':
                cipher.min_len = atoi(optarg);
                cout << "Length of min word option selected.";
                break;
            case 'x':
                cipher.dict_file = optarg;
                cout << "Dict option selected.";
                break;
            case 'i':
                cipher.input_file = optarg;
                cout << "Input option selected.";
                break;
            case 'o':
                cipher.output_file = optarg;
                cout << "Output option selected.";
                break;
            case 'h':
                cout << 
                    "Arguments:"
                    "\n\t-e,|-encrypt encode the file"
                    "\n\t-d,|-decrypt decode the file"
                    "\n\t-n,|-lines number of lines of text to generate"
                    "\n\t-l,|-length minimum word length (default 3)"
                    "\n\t-x,|-dict location of dictionary containing the word list" 
                    "\n\t-i,|-input filename input text from filename (if absent, write to standard output)"
                    "\n\t-o,|-output filename output text (of shift values) to filename (if absent, write to standard output)"
                    "\n\t-h,|-help pull up a list of options";
                break;
            default: 
                cerr << "Unknown option. See -h for a list of options.";
                return 1;
        }
    }
    
    vector<vector<string>> lines;
    parse_dict(lines, cipher.dict_file);

    if (cipher.encrypt == true)
        encoder(cipher, lines);
    else if (cipher.encrypt == false)
        decoder(cipher, lines);

    return 0;
}
